= labelbuddy documentation
Jérôme Dockès <jerome@dockes.org>
:experimental:
:toc: left
:lang: en
:webfonts!:
:sectnums:
:idprefix:
:idseparator: -
:toclevels: 2
:docinfo: shared
:prewrap!:
:source-highlighter: pygments
:pygments-style: lovelace
:homepage: https://jeromedockes.github.io/labelbuddy/
:downloadspage: https://jeromedockes.github.io/labelbuddy/installation.html
:lbppa: https://launchpad.net/~jdockes/+archive/ubuntu/labelbuddy
:lbppapackages: https://launchpad.net/~jdockes/+archive/ubuntu/labelbuddy/+packages
:ghreleases: https://github.com/jeromedockes/labelbuddy/releases
:ghrepo: https://github.com/jeromedockes/labelbuddy/
:lblicense: https://github.com/jeromedockes/labelbuddy/blob/main/LICENSE.txt
:sqlitehome: https://www.sqlite.org/
:sqlite: pass:q[*SQLite*]
:lb: pass:q[*labelbuddy*]
:doca: pass:q[*doccano*]
:libreoffice-calc: pass:q[*LibreOffice Calc*]
:excel: pass:q[*Microsoft Excel*]
:ietab: pass:q[*"`Import / Export`"* tab]
:annotab: pass:q[*"`Annotate`"* tab]
:dstab: pass:q[*"`Dataset`"* tab]
:iet: pass:q[*"`Import / Export`"*]
:annot: pass:q[*"`Annotate`"*]
:dst: pass:q[*"`Dataset`"*]
:extra-edit: pass:q["`Extra annotation data`"]


ifndef::env-github[]
ifdef::lbversion[]
This document describes {homepage}[{lb}] version *{lbversion}*.
endif::[]
endif::[]

== Introduction

{lb} is an {lblicense}[open-source] desktop GUI application for annotating documents.
It can be used for example for Part Of Speech tagging, Named Entity Recognition, sentiment analysis and document classification ...

It aims to be easy to install and use, and can efficiently handle many documents and annotations.

=== labelbuddy vs other annotation tools

There exist several tools for annotating documents.
Most of them, such as https://doccano.github.io/doccano/[doccano] and https://labelstud.io/[labelstudio] are meant to run on a web server and be used online.
If you are crowdsourcing annotations and want users to annotate documents online you should turn to one of these tools.

However if you do not plan to host such a tool on a server, it may not be convenient for each annotator to install one of these rather complex programs and run a local server and database management system on their own machine in order to annotate documents.
In this case, it may be easier to rely on a desktop application such as {lb}, which is a more lightweight solution.

A <<managing-projects,labelbuddy database>> is just an ordinary file that you can copy or share like any other file.
Therefore managing annotations with {lb} is just as simple as if the annotations were stored in plain text formats or {libreoffice-calc} or {excel} spreadsheets.
However {lb} is a more convenient and powerful tool for creating and editing the annotations.

{lb} supports the input and output formats of {doca} so it is <<copying-annotations-to-and-from-doccano,possible>> to switch from one to the other or to combine the work of annotators that use either.

=== Quick start

Start by {downloadspage}[installing] {lb}.
Then to give it a try, you can start {lb} and open a (temporary) demo database by invoking it as:

....
labelbuddy --demo
....

(You can also start {lb} without any options and then select menu:File[Demo] in the GUI.)
You can play around with {lb}’s features in this temporary database.
If you decide to start creating annotations that you want to keep, open a new database and import your <<importing-documents,documents>> and <<importing-labels,labels>>.

== Using labelbuddy

The labelbuddy interface is organized around three tabs: the {ietab} for importing and exporting documents, labels and annotations, the {dstab} to get an overview and manage documents and labels in the database, and the {annotab} is where you annotate documents.

Documents and labels can be imported into a {lb} database from various formats.
Once this is done, you can annotate the documents and finally export your annotations.
It is also possible to import annotations exported from {lb} or {doca}.
This section describes how to perform each of these operations.

Importing and exporting data can be done from the graphical or the <<command-line-interface,command line>> interface.
Documents, labels and annotations that are already in the database are skipped if you try to import them again (but you can import new annotations for an existing document).


=== Importing documents

In the {ietab}, click btn:[Import docs & annotations] and select a file containing the documents you plan to annotate.

When importing a new document into {lb}, several attributes can be specified (exactly how will depend on the format used as described in the following sections):

[horizontal]
`text`:: the content of the document – mandatory.

All other attributes are optional:

[horizontal]
`meta`:: a mapping of user-defined metadata. You can use it to associate some information with the document, for example an identifier, DOI, author... This data is not used by {lb}. It is stored and bundled with the document when you export it.
`short_title`:: displayed in the {annotab} when annotating the document.
`long_title`:: displayed in the document list in the {dstab}
`title`::
* displayed in the {annotab} if `short_title` is missing (if both are missing nothing is displayed).
* displayed in the {dstab} if `long_title` is missing (if both are missing the beginning of `text` is displayed).

TIP: You can use the `short_title` to display essential metadata or short instructions specific to a document.
It can contain links by using an html `<a>` tag.

This information can be provided in several plain text formats described in the following sections.
The format is deduced from the filename extension.

Note that {lb} only deals with plain text documents.
Other formats will need to be converted to plain text, for example using https://www.xpdfreader.com/pdftotext-man.html[pdftotext] if they are in PDF, or https://pandoc.org/[pandoc] (specifying the target format as "plain") for many other formats.

==== From `.txt`

The simplest format you can use is a `.txt`.
In this case, the file must contain the text of one document per line.
The newlines that separate documents are not considered part of the document and are discarded.

While convenient, this format has some limitations: you cannot specify any other document attributes than the text, and the documents cannot contain newlines.
Moreover, the file’s encoding will be interpreted based on your locale settings.
The other import formats share none of these limitations.

==== From `.json`

The file must be a JSON file containing one JSON array.
Each element of the array represents one document.
These elements are JSON objects containing at least the key `text`, and any of the optional attributes.
If provided, `meta` must be a JSON object containing user data about the document.

Therefore an imported JSON file might look like:

[source,json]
----
[
{"text": "text of first doc", "meta": {"author": "me", "DOI": "123"}},
{"text": "text of second doc", "short_title": "doc456"}
]
----

Moreover, it is also possible to <<importing-annotations,import annotations>> together with a new document, or for a document already in the database.

Detail: besides the object format above, {lb} also accepts another format, providing one JSON array per document.
In this case the first (mandatory) element of the array is the text, and the second (optional) one is `meta`.
Other attributes cannot be specified.
[source,json]
----
[
["text of first doc", {"title": "doc 1", "DOI": "123"}],
["text of second doc"]
]
----

==== From `.jsonl`

When importing a `.json` file the whole file is read into memory before inserting the documents in the database.
To read documents one by one and reduce memory usage, you can use https://jsonlines.org/[JSON Lines].
It is similar to the JSON format, but instead of having one JSON array, the file must contain one JSON document per line.
For example:
[source,json]
----
{"text": "text of first doc", "meta": {"author": "me", "DOI": "123"}}
{"text": "text of second doc", "short_title": "doc456"}
----
Note the outer brackets are removed and the documents are not separated by commas.
The object representing each document must occupy exactly one line, unlike in `.json` where whitespace is not important.

As for `.json`, `.jsonl` also allows <<importing-annotations,importing annotations>>.

==== From `.xml`

You can also use a simple XML format.
In this case as well, the documents are read one by one.
The root element must be `document_set` and contain any number of `document` elements.
Each `document` contains the text and any additional information.
User metadata is provided in the attributes of an element named `meta`.
A `document`’s children can appear in any order.

For example:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<document_set>
  <document>
    <text>text of first doc</text>
    <meta DOI="123" author="me"/>
  </document>
  <document>
    <text>text of second doc</text>
    <short_title>doc456</short_title>
  </document>
</document_set>
----

The same format can be used to <<importing-annotations,import annotations>>.

=== Importing labels

To import labels, click btn:[Import labels] in the {ietab}.
Labels have three attributes: a mandatory `text` (label name), and an optional `color` and `shortcut_key`.
The `shortcut_key` is a lower-case ASCII letter (a-z) that helps quickly <<annotating-documents,annotating text>> with that label.

For compatibility with {doca}, `color` can also be specified as `background_color` and `shortcut_key` can be specified as `suffix_key`.

As for documents, the format is deduced from the filename extension when importing labels.
It is also possible to add a new label or change the color or shortcut key from within the GUI application.

==== From `.txt`

The text file contains one label per line. For example:

....
Noun
Verb
Adjective
....

To specify a color or shortcut key (or to use labels that contain newlines), use the `.json` format.

==== From `.json`

The file must contain a JSON array containing one JSON object per label.

Each label's object must have the key `text` and optionally `color` and `shortcut_key` (or their synonyms `background_color` and `suffix_key`, which have lower precedence).

For example:

[source,json]
----
[
{"text": "Noun", "color": "#ff0000"},
{"text": "Verb", "color": "yellow", "shortcut_key": "v"},
{"text": "Adjective"}
]
----

Detail: besides the object format above, {lb} also accepts another format, providing one JSON array per label.
In this case the first (mandatory) element of the array is the text (label name), and the second (optional) one is the color.
[source,json]
----
[
["Noun", "#ff0000"],
["Verb", "yellow"],
["Adjective"]
]
----

There are no `.jsonl` or `.xml` formats for representing labels.

=== Annotating documents

Once you have imported labels and documents you can see them in the {dstab}.
You can filter which documents are shown by the labels they have been annotated with.
You can delete labels or documents, add labels and change the color and shortcut associated with each label.
You then go to the {annotab}.
(If you double-click a document or press kbd:[Enter] after selecting it it will be opened in the {annotab}.)

To annotate a document, select the region you want to label with the mouse and click on the appropriate label.
It is also possible to do the same thing with the keyboard.
Search for the term you want to annotate and the first match will be selected.
The selection can be adusted with the keyboard using the bindings described <<keybindings-summary,below>>.
Then press the shortcut key associated with the label you want to set.
You can also attach additional information to the annotation by typing it in the {extra-edit} box.
Use this to add a comment, or for free-form labelling -- for example enter a number, the normalized name of an entity, a URI, etc. that an Information Extraction system should find in the labelled region.

Once you have created annotations, you can select any of them by clicking it.
It becomes [.blue-bg.active-anno]#underlined# and you can edit its additional data, change its label by clicking on a different one or remove the annotation by clicking btn:[Remove].
You can also do this with the keyboard: jump to the next annotation with the kbd:[Space] key and change its label with a label shortcut or remove it with kbd:[Backspace].

TIP: If the selected annotation is not visible enough you can also make it *bold* by selecting  menu:Preferences[Show selected annotation in bold font].

TIP: If you are doing document classification and need global labels for the documents, just annotate any arbitrary portion of text.
If you need to tag some document status such as "approved", "in progress", etc., add a label for that!
You can then use it to filter documents in the {annotab}.
If you need free-form labels, use a generic label name and type the free-form annotation in the {extra-edit} box.

==== Overlapping annotations

When two or more annotations overlap, the whole group is shown in [.annotation-cluster]##white text on a gray background##.
As you click the gray region or press the kbd:[Space] key, each [.annotation-cluster]##annotation is ##[.active-anno.blue-bg]##selected##[.annotation-cluster]## in turn## and shown in its label's color.

The status bar on the bottom of the window shows a caret ("`^`") next to the label name when the selected annotation is the first of its overlapping group (and "`^^`" when it is the first in the document).


[#keybindings-summary]
==== Summary of key bindings in the {annotab}

[cols="1,2"]
|===
2+| Searching and navigation

| kbd:[Ctrl] and scroll the mouse
| zoom or dezoom the text (for persistent settings, use menu:Preferences[Choose font] )

| kbd:[Ctrl+F], kbd:[/]
| search

| kbd:[Enter]
| next search match

| kbd:[Shift+Enter]
| previous search match

| kbd:[Ctrl+J], kbd:[Ctrl+N], kbd:[Down]
| scroll down one line

| kbd:[Ctrl+K], kbd:[Ctrl+P], kbd:[Up]
| scroll up one line

| kbd:[Ctrl+D]
| scroll down one page

| kbd:[Ctrl+U]
| scroll up one page

| kbd:[Ctrl+L]
| cycle between placing the cursor at the center, top and bottom of the window
|===

[cols="1,2"]
|===
2+| Manipulating annotations

| kbd:[A-Z] (label's `shortcut_key`)
| set corresponding label for the currently selected region or annotation

| kbd:[Backspace]
| remove selected annotation

| kbd:[Alt+E]
| edit the extra annotation data (then press kbd:[Enter] to return focus to the text)

| kbd:[Space]
| jump to next annotation and select it

| kbd:[Shift+Space]
| jump to previous annotation and select it

| kbd:[Esc]
| un-select selected annotation
|===

[cols="1,2"]
|===
2+| Manipulating the text selection

| kbd:[\]]
| move the *end* of the selection by one *word* to the *right*

| kbd:[[]
| move the *end* of the selection by one *word* to the *left*

| kbd:[}]
| move the *beginning* of the selection by one *word* to the *right*

| kbd:[{]
| move the *beginning* of the selection by one *word* to the *left*

| kbd:[Ctrl+\]]
| move the *end* of the selection by one *character* to the *right*

| kbd:[Ctrl+[]
| move the *end* of the selection by one *character* to the *left*

| kbd:[Ctrl+}]
| move the *beginning* of the selection by one *character* to the *right*

| kbd:[Ctrl+{]
| move the *beginning* of the selection by one *character* to the *left*
|===

[cols="1,2"]
|===
2+| Navigating documents

| kbd:[>]
| go to next document

| kbd:[<]
| go to previous document
|===

Moreover, you can use kbd:[Alt+A], kbd:[Alt+D] and kbd:[Alt+I] to jump to the {annot}, {dst} and {iet} tabs respectively.
More generally underlined letter in the GUI indicate kbd:[Alt]-key shortcuts: for example "`[.underline]##N##ew label`" indicates you can jump to creating a new label by pressing kbd:[Alt+N].

=== Exporting documents and annotations

Once you are satisfied with your annotations you can export them to an `.json`, `.jsonl` or `.xml` file to share them or use them in other applications.

Back in the {ietab}, click btn:[Export docs & annotations].
You can choose to export all documents or only those that have annotations.
You can choose to export the text of the documents or not.
If you don’t export the text, the documents can be identified from metadata you may have associated with them, or by the MD5 checksum of the text that is always exported.
You can also provide an "`annotation approver`" (user name), that will be exported as the `annotation_approver` (used by {doca}).
You can also choose to only export the documents, without the annotations.

When clicking btn:[Export docs & annotations] you are asked to select a file and the resulting format will depend on the filename extension.
The export format is the same as the import format.
Exported documents and annotations can thus be imported back into a {lb} database.

Compared to previous description of the import format, in exported documents:

* `text` is optional (you can choose not to export it to save space, in this case documents can be identified from their MD5 checksum or from the user metadata).
* `document_md5_checksum` (containing the hex representation of the MD5 checksum of the text) and `labels` (containing the document’s annotations) are added.
The optional attribute `annotation_approver` can also be added.

`labels` is a list of annotations, each represented by a sequence of:

[horizontal]
`start_char`:: the position of the first character (starting from 0 at the begining of the text)
`end_char`:: the position of one past the last character
`label`:: the label name.
`extra_data` (optional):: additional text associated with the annotation.

For example if the text starts with "`hello`" and you highlighted exactly that word, and labelled it with `label_1`, the associated annotation will be `[0, 5, "label_1"]`.
If you also typed "`some more info`" in the {extra-edit} box, the annotation will be `[0, 5, "label_1", "some more info"]`.

NOTE: Documents are exported in the same order that they were imported.

==== Exporting to `.json`

JSON exported annotations might look like:

[source,json]
----
[
{"annotation_approver":"jerome","document_md5_checksum":"f5a42de39848dbdadf79aade46135b7a","labels":[[0,4,"Noun"]],"meta":{"DOI":"123","author":"me"},"text":"text of first doc"},
{"annotation_approver":"jerome","document_md5_checksum":"d5c080bd4c6033f977182e757a0059b1","labels":[[0,4,"Verb", "some more info: 4"],[8,14,"Adjective"]],"meta":{}, "text":"text of second doc", "short_title": "doc456"}
]
----

Each document will always be on one separate line; this makes it easy to parse the file incrementally.
Moreover as the documents are always in the same order, it gives line-oriented tools such as *diff* or *git* a better chance of producing useful output.

==== Exporting to `.jsonl`

If you choose to export to a https://jsonlines.org/[JSON lines] file, the content will be almost the same as the JSON one, but with just one JSON object per line and not one JSON array containing all the documents:

[source,json]
----
{"annotation_approver":"jerome","document_md5_checksum":"f5a42de39848dbdadf79aade46135b7a","labels":[[0,4,"Noun"]],"meta":{"DOI":"123","author":"me"},"text":"text of first doc"}
{"annotation_approver":"jerome","document_md5_checksum":"d5c080bd4c6033f977182e757a0059b1","labels":[[0,4,"Verb", "some more info: 4"],[8,14,"Adjective"]],"meta":{}, "text":"text of second doc", "short_title": "doc456"}
----

==== Exporting to `.xml`

If you choose a `.xml` file the result is a UTF-8 encoded XML document.
Again the format is the same as for importing with some additional elements (and possibly no text).

So it may look like:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<document_set>
    <document>
        <text>text of first doc</text>
        <document_md5_checksum>f5a42de39848dbdadf79aade46135b7a</document_md5_checksum>
        <meta DOI="123" author="me"/>
        <annotation_approver>jerome</annotation_approver>
        <labels>
            <annotation>
                <start_char>0</start_char>
                <end_char>4</end_char>
                <label>Noun</label>
            </annotation>
        </labels>
    </document>
    <document>
        <text>text of second doc</text>
        <document_md5_checksum>d5c080bd4c6033f977182e757a0059b1</document_md5_checksum>
        <meta/>
        <annotation_approver>jerome</annotation_approver>
        <short_title>doc456</short_title>
        <labels>
            <annotation>
                <start_char>0</start_char>
                <end_char>4</end_char>
                <label>Verb</label>
                <extra_data>some more info: 4</extra_data>
            </annotation>
            <annotation>
                <start_char>8</start_char>
                <end_char>14</end_char>
                <label>Adjective</label>
            </annotation>
        </labels>
    </document>
</document_set>
----

CAUTION: https://en.wikipedia.org/wiki/Valid_characters_in_XML[Invalid characters] (for example form feed, `0xC`) will not be written to the output.
JSON can represent all Unicode characters, including some characters that are invalid in XML.
Thus if you imported documents from JSON or JSONL and there is a chance that they contain invalid XML characters, it is safer to choose JSON or JSONL as the export format so that no characters are ommitted in the output.

=== Exporting labels

You can also export labels by clicking "`Export labels`" and selecting a JSON file.
The resulting file will contain an array of json objects; the same format as the <<from-json,input format>>.
Unlike documents each label is not on a single line.
Both keys `color` and `background_color` are set to the label's color.
Both keys `shortcut_key` and `suffix_key` are set to the label's shortcut key if it has one.

=== Importing annotations

Exported annotations can be imported back into the same or another {lb} database.
Simply use the btn:[Import docs & annotations] button and select the exported file.
Labels used in the annotations that are not in the database will be added (with an arbitrary color that can be
changed in the application).

For documents already in the database, annotations will be imported whether the document’s text was exported together with the annotations or not.
If the text is not present in the exported file, the MD5 checksum will be used to associate the annotations with the correct document.

Annotations already in the database (same label at the same position in the same document) will not be inserted, so it is not a problem to import the same documents and annotations several times.

For documents that are not in the database, their text must have been exported together with the annotations and in this case both the document and the annotations will be added to the database.

==== Copying annotations to and from doccano

Documents and annotations exported from {doca} can also be imported into a {lb} database.
To do so, when exporting from {doca} select the format "`jsonl (text label)`".
Make sure to save them in a file with the `.jsonl` extension (not `.json`) otherwise {lb} will try to parse it as JSON and JSON Lines is not valid JSON.

CAUTION: {doca} strips leading and trailing whitespace from documents when importing them.
Therefore if you import the result into a {lb} database that already contains the original documents, it may not be recognized as being the same ({lb} doesn’t modify the imported documents) and you might end up with (near) duplicate documents in the database.

Annotations exported from {lb} in the `.jsonl` format together with the document’s text can also be imported into {doca} (selecting the "`jsonl`" import format).

CAUTION: If the original document contained leading whitespace, {lb} annotations will appear shifted when {doca} removes the whitespace.
Moreover, {doca} allows duplicate documents so if the documents were already in the {doca} database, they will appear as new (duplicate) documents rather than new annotations for existing documents.

[CAUTION]
====
If you used {lb} features that do not exist in {doca}, you will not be able to import the resulting annotations into {doca}:

- if you have attached extra data to the annotations, {doca} will not recognize the format and will not import the annotations.
- {doca} does not allow overlapping annotations.
Therefore if you try to import overlapping annotations (created with {lb}) into {doca} the results will be incorrect; annotated text will appear duplicated and jumbled.
====


=== Managing projects

Each {lb} database (containing documents, labels and annotations) is an {sqlitehome}[SQLite] database.
That is a single regular file on your disk that you can copy, backup, or share, like any other file.
Therefore managing {lb} data is as simple as if you were storing annotations in a {libreoffice-calc} or {excel} spreadsheet, for example.

TIP: Using {sqlite} you can also open a connection directly to the database to query it or even modify it.
If you do so, set `PRAGMA foreign_keys = ON`.

After starting {lb}, you can create a new database or open an existing one by selecting menu:File[Open].
If you used {lb} before, by default at startup it opens the last database that you used.
The database to open can also be specified when invoking {lb} from the command line:
....
labelbuddy /path/to/my_project.labelbuddy
....

The path to the current database is displayed in the {ietab}.

If you just want to give {lb} a try and don’t have documents or labels yet, you can also select menu:File[Demo] to open a temporary database pre-loaded with a few examples.

As it is easy to create, copy and delete databases (an empty {lb} database is just 60K), and to copy documents, labels and annotations from one to another, you have some freedom in the organization of annotation work.
For example, you can break down the annotations into several files to reflect the structure of your project or to limit the number of documents in each {lb} file.

=== Command-line interface

{lb} can also be used from the command line to create databases, import and export documents, labels and annotations without opening the GUI.
See the `labelbuddy(1)` <<manpage#,*man* page>>, or `labelbuddy -h` for a short list of options reproduced here:

....
Usage: ./labelbuddy [options] [database]
Annotate documents.

Options:
  -h, --help                              Displays this help.
  -v, --version                           Displays version information.
  --demo                                  Open a temporary demo database with
                                          pre-loaded docs
  --import-labels <labels file>           Labels file to import in database.
  --import-docs <docs file>               Docs & annotations file to import in
                                          database.
  --export-labels <exported labels file>  Labels file to export to.
  --export-docs <exported docs file>      Docs & annotations file to export to.
  --labelled-only                         Export only labelled documents
  --no-text                               Do not include doc text when
                                          exporting
  --no-annotations                        Do not include annotations when
                                          exporting
  --approver <name>                       User or 'annotations approver' name
  --vacuum                                Repack database into minimal amount
                                          of disk space.

Arguments:
  database                                Database to open.
....

If any of the `import-` or `export-` options are used, {lb} doesn’t start a GUI but performs the required import or export operations and exits.
It is possible to specify these options several times.
To use these options, the database path must be provided explicitly.

Labels are imported first, then documents, then export operations are performed.
Therefore it is possible to export documents and then export them in one execution of {lb}.
As an example, to strip the annotations from previously exported documents you could run:
....
labelbuddy tempdb --import-docs docs.jsonl --export-docs unlabelled-docs.jsonl --no-annotations; rm tempdb
....
Or even (using {sqlite}'s in-memory database):
....
labelbuddy :memory: --import-docs docs.jsonl --export-docs unlabelled-docs.jsonl --no-annotations
....

Regarding `vacuum`: when data is deleted from an {sqlite} database, the file doesn’t shrink.
The freed up space is not lost; it is kept and reused when new data is added to the database.
To shrink the database to occupy a minimal amount of disk space, we can use:
....
labelbuddy --vacuum /path/to/db.labelbuddy
....
or equivalently:
....
sqlite3 /path/to/db.labelbuddy 'VACUUM;'
....
See more details https://sqlite.org/lang_vacuum.html[here].
When the `vacuum` option is used, other options are ignored and {lb} shrinks the database then exits without starting the GUI.

== Conclusion

{lb} was created using C++, https://www.qt.io/[Qt], {sqlitehome}[SQLite], tools from the https://www.gnu.org/[GNU project], and more.

If you find a bug or have suggestions to improve {lb}, kindly open an issue on the {ghrepo}[labelbuddy GitHub repository].
